"use strict";(self.webpackChunkaelf_dev_2402=self.webpackChunkaelf_dev_2402||[]).push([[7533],{7804:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var r=n(4848),i=n(8453);const o={title:"Context",sidebar_position:2},s=void 0,a={id:"additional/more-about-contract/5.2 context",title:"Context",description:"Also, inputs of a contract method including the following available context (Chain State):",source:"@site/docs/5. additional/more-about-contract/5.2 context.md",sourceDirName:"5. additional/more-about-contract",slug:"/additional/more-about-contract/5.2 context",permalink:"/aelf-dev-2402/docs/additional/more-about-contract/5.2 context",draft:!1,unlisted:!1,editUrl:"https://github.com/kokkoon/aelf-dev-2402/tree/main/docs/5. additional/more-about-contract/5.2 context.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Context",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"State Types",permalink:"/aelf-dev-2402/docs/additional/more-about-contract/5.1 state-types"},next:{title:"View Methods",permalink:"/aelf-dev-2402/docs/additional/more-about-contract/5.3 view-methods"}},c={},d=[];function l(t){const e={a:"a",code:"code",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"Also, inputs of a contract method including the following available context (Chain State):"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Chain State"}),(0,r.jsx)(e.th,{children:"Usage"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.ChainId"}),(0,r.jsx)(e.td,{children:"Get current chain id."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.CurrentHeight"}),(0,r.jsx)(e.td,{children:"Get the block height when executing current transaction."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.CurrentBlockTime"}),(0,r.jsx)(e.td,{children:"Get the block time when executing current transaction."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.Self"}),(0,r.jsx)(e.td,{children:"Get the address of current contract."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.Sender"}),(0,r.jsx)(e.td,{children:"Get the sender address of executing transaction."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.Origin"}),(0,r.jsx)(e.td,{children:"Get the address of original transaction signer."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.Transaction"}),(0,r.jsx)(e.td,{children:"Get executing transaction."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.PreviousBlockHash"}),(0,r.jsx)(e.td,{children:"Get the block hash of previous block."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.TransactionId"}),(0,r.jsx)(e.td,{children:"Get the TransactionId of the executing transaction."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.OriginTransactionId"}),(0,r.jsx)(e.td,{children:"Get the TransactionId of the original transaction."})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Context.Variables"}),(0,r.jsxs)(e.td,{children:["Get variables configured during the launching of current chain. For example, on aelf MainChain:",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)(e.code,{children:"Context.Variables.NativeSymbol"})," will return ",(0,r.jsx)(e.code,{children:"ELF"})]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(e.code,{children:"Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)"})," will return ",(0,r.jsx)(e.code,{children:'{"WRITE","STORAGE","READ","TRAFFIC"}'})]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(e.code,{children:"Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)"})," will return ",(0,r.jsx)(e.code,{children:'{"CPU","RAM","DISK","NET"}'})]})]})]})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:["Additional explanation, as mentioned earlier, the method implementation of the contract is used to describe how the State should change, so class libraries unrelated to describing this logic are prohibited in the development process of the aelf contract. You can obtain restriction information from ",(0,r.jsx)(e.a,{href:"https://docs.aelf.io/en/latest/architecture/smart-contract/restrictions/type.html",children:"this"})," page."]})]})}function h(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>s,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function s(t){const e=r.useContext(o);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:s(t.components),r.createElement(o.Provider,{value:e},t.children)}}}]);