"use strict";(self.webpackChunkaelf_dev_2402=self.webpackChunkaelf_dev_2402||[]).push([[5422],{2636:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var o=n(4848),a=n(8453);const r={title:"Inline Contract Call",sidebar_position:4},i=void 0,c={id:"additional/more-about-contract/5.4 inline-contract-call",title:"Inline Contract Call",description:"When you need to call methods from other contracts during the implementation of your own contract methods, there are two types:",source:"@site/docs/5. additional/more-about-contract/5.4 inline-contract-call.md",sourceDirName:"5. additional/more-about-contract",slug:"/additional/more-about-contract/5.4 inline-contract-call",permalink:"/aelf-dev-2402/docs/additional/more-about-contract/5.4 inline-contract-call",draft:!1,unlisted:!1,editUrl:"https://github.com/kokkoon/aelf-dev-2402/tree/main/docs/5. additional/more-about-contract/5.4 inline-contract-call.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Inline Contract Call",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"View Methods",permalink:"/aelf-dev-2402/docs/additional/more-about-contract/5.3 view-methods"},next:{title:"Events",permalink:"/aelf-dev-2402/docs/additional/more-about-contract/5.5 events"}},s={},l=[];function d(t){const e={code:"code",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"When you need to call methods from other contracts during the implementation of your own contract methods, there are two types:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Call view methods without expecting to modify any states of other contracts."}),"\n",(0,o.jsx)(e.li,{children:"Call action methods and hope that the states of other contracts will be modified because of this calling."}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["For the first type, you can use ",(0,o.jsx)(e.code,{children:"Context.Call"})," method to complete the call to the view methods and immediately obtain the return value, which can be applied in the context of the contract implementation."]}),"\n",(0,o.jsxs)(e.p,{children:["For the second type, during the implementation of the AELF contract, all you can do is prepare a transaction without a signature (we call it an ",(0,o.jsx)(e.strong,{children:"inline transaction"}),") and ",(0,o.jsx)(e.strong,{children:"add it to a list"}),". Transactions on this list will be executed one by one recursively, following the completion of the code for the method you have implemented, based on the time it was added."]}),"\n",(0,o.jsxs)(e.p,{children:["Therefore, it should be noted that on aelf, when you try to modify the states of other contracts, the modification does not occur immediately. It can only be gradually modified through ",(0,o.jsx)(e.strong,{children:"inline transactions"})," after the current contract method has been fully executed. This is different from EVM."]}),"\n",(0,o.jsxs)(e.p,{children:["You can use the ",(0,o.jsx)(e.code,{children:"Context.SendInline"})," method to add an inline transaction to the current executing context."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'// A method that modifies the contract state\npublic override Empty Update(StringValue input)\n{\n    var tokenContractAddress = Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);\n    // Do not forget to reference token_contract.proto to generate the TransferInput type.\n    Context.SendInline(tokenContractAddress, "Transfer", new TransferInput\n    {\n        To = receiverAddress,\n        Symbol = "ELF",\n        Amount = 100\n    });\n    // Set the message value in the contract state\n    State.Message.Value = input.Value;\n    // Emit an event to notify listeners about something happened during the execution of this method\n    Context.Fire(new UpdatedMessage\n    {\n        Value = input.Value\n    });\n    return new Empty();\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["In the above example, an inline transaction for transfer was added in the beginning of Update method, which attempts to call the ",(0,o.jsx)(e.strong,{children:"Transfer"})," method of the ",(0,o.jsx)(e.strong,{children:"MultiToken Contract"})," (one of the System Contracts) and will only be executed after the Update method is completed."]}),"\n",(0,o.jsxs)(e.p,{children:["Of course, cross contract calls can also be completed through ",(0,o.jsx)(e.strong,{children:"ContractReferenceState"}),". ContractReferenceState is only meant to facilitate developers to call methods in other contracts, essentially the ",(0,o.jsx)(e.code,{children:"Context.Call"})," and ",(0,o.jsx)(e.code,{children:"Context.SendInline"})," are used to complete such tasks."]})]})}function h(t={}){const{wrapper:e}={...(0,a.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(d,{...t})}):d(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>i,x:()=>c});var o=n(6540);const a={},r=o.createContext(a);function i(t){const e=o.useContext(r);return o.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function c(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:i(t.components),o.createElement(r.Provider,{value:e},t.children)}}}]);